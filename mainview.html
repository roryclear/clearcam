<!DOCTYPE html>
<html>
<head>
  <style>
    .camera-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .camera-card {
      width: 480px;
      border: 1px solid #ccc;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
      font-family: sans-serif;
    }
    .camera-card .video-container {
      width: 100%;
      height: 320px;
      background: #000;
      position: relative;
    }
    .camera-card video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    .camera-card .video-placeholder {
      width: 100%;
      height: 100%;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
      position: absolute;
      top: 0;
      left: 0;
    }
    .camera-card .camera-info {
      padding: 12px;
      background: #f9f9f9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .camera-card .camera-name {
      font-weight: bold;
      cursor: pointer;
      color: #007bff;
      text-decoration: none;
      font-size: 18px;
    }
    .camera-card .camera-name:hover {
      text-decoration: underline;
    }
    .camera-card button {
      padding: 8px 16px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .camera-card button:hover {
      background: #c82333;
    }
    .form-section {
      margin-top: 20px;
      font-family: sans-serif;
    }
    .form-section input {
      padding: 6px;
      margin: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 200px;
    }
    .form-section button {
      padding: 6px 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .form-section button:hover {
      background: #0056b3;
    }
    .shutdown-wrapper {
      margin-top: 20px;
    }

    #zoneModal button {
        padding: 8px 16px;
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-family: sans-serif;
    }

    #zoneModal button:hover {
        background: #c82333;
    }

    #zoneModal label {
        font-family: sans-serif;
        font-size: 14px;
    }

    #zoneModal input[type="number"] {
        padding: 6px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
        font-family: sans-serif;
    }

    #zoneModal input[type="checkbox"] {
        margin: 0;
    }
    #zoneModal h3 {
        font-family: sans-serif;
        margin: 0;
    }

    #zoneModal .modal-header h3 {
        font-family: sans-serif;
    }

    #zoneModal div {
        font-family: sans-serif;
    }

    #zoneModal {
        font-family: sans-serif;
    }

    /* Multi-view overlay grid */
    #multiView {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: black;
      z-index: 9999;
      padding: 10px;
      box-sizing: border-box;
      justify-content: center;
      align-items: center;
      grid-gap: 10px;
    }
    #multiView.active {
      display: grid;
      justify-items: center;
      align-items: center;
    }
    #multiView .video-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #multiView video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    .multi-view-wrapper {
      margin-top: 10px;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .multi-view-wrapper button {
      padding: 6px 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .multi-view-wrapper button:hover {
      background: #0056b3;
    }
    .date-picker-container {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .date-picker-container input {
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }

    /* Event Images Styles */
    .events-section {
      margin-top: 20px;
      font-family: sans-serif;
    }
    .events-section h3 {
      margin-bottom: 10px;
      color: #333;
    }
    #eventImagesContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      justify-content: flex-start;
    }
    .event-image-item {
      position: relative;
      width: 220px;
      border-radius: 10px;
      border: 1px solid #ccc;
      overflow: hidden;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }
    .event-image-item:hover {
      transform: scale(1.05);
    }
    .event-image-item img {
      width: 100%;
      height: 150px;
      object-fit: cover;
      cursor: pointer;
    }
    .event-image-info {
      padding: 8px;
      font-size: 12px;
      color: #666;
    }
    .event-image-actions {
      display: flex;
      gap: 6px;
      padding: 8px;
      justify-content: space-between;
    }
    .event-image-actions button {
      padding: 6px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .event-image-actions button:hover {
      background: #0056b3;
    }
    #imagePreviewModal {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.9);
      justify-content: center;
      align-items: center;
    }
    #previewImage {
      max-width: 90%;
      max-height: 90%;
      object-fit: contain;
    }
    .modal-content {
        width: 95%;
        padding: 15px;
    }
    .close-preview {
      position: absolute;
      top: 20px;
      right: 30px;
      color: white;
      font-size: 40px;
      font-weight: bold;
      cursor: pointer;
    }
    .close-preview:hover {
      color: #ccc;
    }
    
    /* Icon styles */
    .icon {
      display: inline-block;
      width: 16px;
      height: 16px;
    }
    .icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
    }

    .modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background-color: #fefefe;
        padding: 20px;
        border-radius: 8px;
        max-width: 600px;
        width: 90%;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        margin: auto;
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .modal-header h3 {
        margin: 0;
    }

    .close {
        color: #aaa;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }

    .close:hover {
        color: black;
    }
  </style>
</head>
<body>
  <div id="cameraList" class="camera-grid"></div>
  <div class="multi-view-wrapper">
    <button onclick="toggleMultiView()">Multi View</button>
    <div class="date-picker-container">
      <input type="date" id="streamDatePicker">
    </div>
  </div>

  <div class="form-section">
    <form id="addCameraForm">
      <input type="text" name="cam_name" placeholder="Camera Name" required>
      <input type="text" name="rtsp" placeholder="RTSP Link" required>
      <button type="submit">Add Camera</button>
    </form>
    <div class="max-storage-control" style="display: flex; flex-direction: column; align-items: flex-start; margin-top: 10px;">
      <label for="maxStorageInput" style="margin-bottom: 4px;">Set Max Storage (GB):</label>
      <div style="display: flex; align-items: center; gap: 6px;">
        <input type="number" id="maxStorageInput" min="1" style="width: 120px;">
        <button type="button" id="setMaxStorageBtn">Set</button>
      </div>
    </div>
    <div class="shutdown-wrapper">
      <button class="shutdown-button" onclick="shutdownServer()">Shutdown Server</button>
    </div>
  </div>

  <div class="events-section">
    <h3>Detected Events</h3>
    <div id="eventImagesContainer">
      <p style="text-align:center; color:#666; width:100%;">No events detected yet.</p>
    </div>
  </div>
  
  <div id="multiView"></div>

  <!-- Image Preview Modal -->
  <div id="imagePreviewModal" class="modal">
    <span class="close-preview" onclick="closeImagePreview()">&times;</span>
    <img id="previewImage" src="" alt="Preview">
  </div>
  
  <div id="zoneModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
            <h3>Edit Zone</h3>
            <span class="close" onclick="closeZoneModal()">&times;</span>
        </div>
        <div style="position: relative; display: inline-block; max-width: 100%;">
            <img id="zonePreview" src="/testcam/preview.png"
                style="width: 100%; max-height: 400px; object-fit: contain; border: 1px solid #ccc; border-radius: 6px; user-select: none; -webkit-user-drag: none; cursor: crosshair;">
            <div id="polygonOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
        </div>
        <div style="margin: 10px 0; text-align: center; color: #666; font-size: 0.9rem;">
            Click on the image to make a detection zone.
        </div>
        <div class="form-actions" style="margin-top: 20px; display: flex; justify-content: space-between; align-items: center; width: 100%;">
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <label style="display: flex; align-items: center; gap: 6px;">
                    <input type="checkbox" id="zoneEnabledCheckbox" checked> Enable Zone
                </label>
                <label style="display: flex; align-items: center; gap: 6px;">
                    <input type="checkbox" id="outsideZoneCheckbox"> Detect outside of zone
                </label>
                <label style="display: flex; align-items: center; gap: 6px;">
                    Detection Threshold:
                    <input type="number" id="zoneThreshold" value="50" min="0" max="100" step="1" style="width: 60px;"> %
                </label>
            </div>
            <div style="display: flex; gap: 10px;">
                <button type="button" onclick="clearPolygon()">Clear Zone</button>
                <button type="button" onclick="closeZoneModal()">Cancel</button>
                <button type="button" onclick="saveZone()">Save</button>
            </div>
        </div>
    </div>
    </div>

  <svg style="display: none;">
    <symbol id="icon-magnify" viewBox="0 0 24 24">
      <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    </symbol>
    
    <symbol id="icon-play" viewBox="0 0 24 24">
      <path d="M8 5v14l11-7z"/>
    </symbol>
    
  <symbol id="icon-play-all" viewBox="0 0 24 24">
    <rect x="2" y="2" width="8" height="8" fill="currentColor"/>
    <rect x="14" y="2" width="8" height="8" fill="currentColor"/>
    <rect x="2" y="14" width="8" height="8" fill="currentColor"/>
    <rect x="14" y="14" width="8" height="8" fill="currentColor"/>
  </symbol>
  </svg>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
    const zoneModal = document.getElementById("zoneModal");

    const activeVideoStreams = new Map();
    let wasHidden = false;
    let currentStreamDate = new Date().toLocaleDateString('en-CA');
    let userIsInteracting = false;

    // Zone editor state - scoped to modal session
    let zoneEditorState = {
        polygonSvg: null,
        polygonPath: null,
        firstPoint: null,
        isPolygonComplete: false
    };

    document.addEventListener('DOMContentLoaded', function() {
      const datePicker = document.getElementById('streamDatePicker');
      datePicker.value = currentStreamDate;
      datePicker.addEventListener('change', function() {
        const selectedDate = this.value;
        if (selectedDate) {
          currentStreamDate = selectedDate;
          console.log('Date changed to:', currentStreamDate);
          restartAllStreams();
          loadEventImages(); // Reload events for the new date
        }
      });

      // Load initial events
      loadEventImages();
      
      // Set up interval to refresh events every 5 seconds
      setInterval(loadEventImages, 5000);
    });

    function isToday(dateString) {
      const today = new Date().toLocaleDateString('en-CA');
      return dateString === today;
    }

    function setupUserInteractionTracking(video) {
      video.addEventListener('seeking', () => {
        userIsInteracting = true;
        console.log('User is scrubbing - disabling auto-seek');
      });
      
      video.addEventListener('seeked', () => {
        setTimeout(() => {
          userIsInteracting = false;
        }, 3000);
      });
      
      video.addEventListener('play', () => {
        userIsInteracting = false;
      });
    }

    function restartAllStreams() {
      console.log('Restarting all streams for date:', currentStreamDate);

      activeVideoStreams.forEach((streamInfo, camName) => {
        cleanupCameraStream(camName);
      });

      if (window.currentCameras) {
        window.currentCameras.forEach(camName => {
          startCameraStream(camName);
        });
      }
    }

    async function fetchCameras() {
      const res = await fetch('/list_cameras');
      const cams = await res.json();
      const container = document.getElementById("cameraList");
      
      const previousCameras = window.currentCameras || [];
      window.currentCameras = cams;

      const existingCards = new Map();
      container.querySelectorAll('.camera-card').forEach(card => {
        const camName = card.dataset.camera;
        if (camName) {
          existingCards.set(camName, card);
        }
      });

      const newCards = [];
      
      cams.forEach(cam => {
        let card = existingCards.get(cam);
        
        if (card) {
          const nameSpan = card.querySelector('.camera-name');
          if (nameSpan && nameSpan.textContent !== cam) {
            nameSpan.textContent = cam;
          }
          newCards.push(card);
        } else {
          card = createCameraCard(cam);
          newCards.push(card);
        }
      });
      
      const currentCards = Array.from(container.children);
      const needsUpdate = newCards.length !== currentCards.length || 
                         !newCards.every((card, index) => currentCards[index] === card);
      
      if (needsUpdate) {
        container.innerHTML = '';
        newCards.forEach(card => container.appendChild(card));
      }
      
      // Start streams for new cameras
      cams.forEach(cam => {
        if (!activeVideoStreams.has(cam)) {
          startCameraStream(cam);
        }
      });
      
      // Clean up streams for removed cameras
      previousCameras.forEach(cameraName => {
        if (!cams.includes(cameraName)) {
          cleanupCameraStream(cameraName);
        }
      });
    }

    function createCameraCard(camName) {
      const card = document.createElement('div');
      card.className = 'camera-card';
      card.dataset.camera = camName;
      
      const videoId = `video-${camName}`;
      const placeholderId = `placeholder-${camName}`;
      
      card.innerHTML = `
        <div class="video-container">
          <video id="${videoId}" controls muted playsinline></video>
          <div class="video-placeholder" id="${placeholderId}">Loading stream...</div>
        </div>
        <div class="camera-info">
          <a href="/?cam=${encodeURIComponent(camName)}" class="camera-name" target="_blank">${camName}</a>
          <button onclick="openSettingsEditor('${camName}')">Settings</button>
          <button onclick="deleteCamera('${camName}')">Delete</button>
        </div>
      `;
      
      return card;
    }

    let currentEditingCamera = null;
    function openSettingsEditor(cameraName) {
        currentEditingCamera = cameraName;
        
        // Reset zone editor state
        zoneEditorState = {
            polygonSvg: null,
            polygonPath: null,
            firstPoint: null,
            isPolygonComplete: false
        };
        
        // Update the zone preview image URL with the actual camera name
        const zonePreview = document.getElementById("zonePreview");
        zonePreview.src = `/${cameraName}/preview.png`;
        
        zoneModal.style.display = "flex";
        initZoneEditor();
          
        // Then load the settings
        fetch(`/get_settings?cam=${cameraName}`)
            .then(res => res.json())
            .then(data => {
                console.log("Received settings data:", data);
                const previewEl = document.getElementById("zonePreview");
                
                // Wait for the new image to load before drawing polygons
                previewEl.onload = function() {
                    if (data && data.coords) {
                        console.log("Loading coords:", data.coords);
                        loadPolygon(data.coords, previewEl);
                    }
                };
                
                // If image is already loaded (cached), draw immediately
                if (previewEl.complete) {
                    if (data && data.coords) {
                        console.log("Loading coords:", data.coords);
                        loadPolygon(data.coords, previewEl);
                    }
                }

                const zoneEnabledCheckbox = document.getElementById("zoneEnabledCheckbox");
                if (data.is_on !== undefined) {
                    zoneEnabledCheckbox.checked = data.is_on;
                } else if (data.length && data[0] && data[0].is_on !== undefined) {
                    zoneEnabledCheckbox.checked = data[0].is_on;
                } else {
                    zoneEnabledCheckbox.checked = false;
                }
                
                const outsideZoneCheckbox = document.getElementById("outsideZoneCheckbox");
                if (data.outside !== undefined) {
                    outsideZoneCheckbox.checked = data.outside;
                } else if (data.length && data[0] && data[0].outside !== undefined) {
                    outsideZoneCheckbox.checked = data[0].outside;
                } else {
                    outsideZoneCheckbox.checked = false;
                }
                
                const thresholdInput = document.getElementById("zoneThreshold");
                let rawThreshold = undefined;
                if (data.threshold !== undefined) {
                    rawThreshold = data.threshold;
                } else if (data.length && data[0] && data[0].threshold !== undefined) {
                    rawThreshold = data[0].threshold;
                }
                if (rawThreshold !== undefined) {
                    if (rawThreshold <= 1) {
                        thresholdInput.value = (rawThreshold * 100).toFixed(0);
                    } else {
                        thresholdInput.value = rawThreshold.toFixed(0);
                    }
                }
            })
            .catch(err => {
                console.error("Failed to load zone:", err);
            });
    }

    function closeZoneModal() {
        zoneModal.style.display = "none";
        currentEditingCamera = null;
        // Clear zone editor state
        zoneEditorState = {
            polygonSvg: null,
            polygonPath: null,
            firstPoint: null,
            isPolygonComplete: false
        };
    }

    function isClickOnPoint(point, clickX, clickY) {
        const pointRect = point.getBoundingClientRect();
        const previewRect = document.getElementById("zonePreview").getBoundingClientRect();
        const pointX = parseInt(point.style.left) + 6; // Center of point
        const pointY = parseInt(point.style.top) + 6;
        
        // Check if click is within the point's area
        const distance = Math.sqrt(Math.pow(clickX - pointX, 2) + Math.pow(clickY - pointY, 2));
        return distance <= 10; // Increased tolerance for easier clicking
    }

    function initZoneEditor() {
        const previewEl = document.getElementById("zonePreview");
        clearPolygon();
        initPolygonOverlay();
        previewEl.addEventListener('click', handlePreviewClick);
    }

    function saveZone() {
        if (!currentEditingCamera) {
            console.error("No camera is currently being edited");
            alert("Error: No camera selected for editing.");
            return;
        }

        const previewEl = document.getElementById("zonePreview");
        const points = Array.from(document.querySelectorAll('.polygon-point'));
        
        let coords = null;
        if (points.length >= 3) {
            const videoWidth = 1280;
            const videoHeight = 720;
            const previewRect = previewEl.getBoundingClientRect();

            coords = points.map(point => {
                const pointRect = point.getBoundingClientRect();
                const centerX = pointRect.left + pointRect.width / 2;
                const centerY = pointRect.top + pointRect.height / 2;
                
                const x = ((centerX - previewRect.left) / previewRect.width) * videoWidth;
                const y = ((centerY - previewRect.top) / previewRect.height) * videoHeight;
                
                return [x, y];
            });
        }

        const is_on = document.getElementById("zoneEnabledCheckbox").checked;
        const outside = document.getElementById("outsideZoneCheckbox").checked;

        const thresholdPercent = parseFloat(document.getElementById("zoneThreshold").value) || 50;
        const threshold = thresholdPercent / 100;
        
        const params = new URLSearchParams({
            cam: currentEditingCamera,
            is_on: is_on,
            threshold: threshold.toFixed(2),
            outside: outside
        });
        
        if (coords) {
            params.set('coords', JSON.stringify(coords));
        }

        fetch(`/edit_settings?${params.toString()}`)
            .then(res => {
                if (!res.ok) throw new Error("Failed to save settings");
                console.log("Settings saved successfully for camera:", currentEditingCamera);
                closeZoneModal();
            })
            .catch(err => {
                console.error("Save settings failed:", err);
                alert("Failed to save settings.");
            });
    }

    function loadPolygon(coords, previewEl) {
      const videoWidth = 1280;
      const videoHeight = 720;
      const img = document.getElementById("zonePreview");
      if (img.complete) {
        drawPolygonCoords(coords, img, previewEl);
      } else {
        img.addEventListener('load', function() {
          drawPolygonCoords(coords, img, previewEl);
        });
      }
    }

    function drawPolygonCoords(coords, img, previewEl) {
      const videoWidth = 1280;
      const videoHeight = 720;
      
      // Get the actual displayed dimensions of the image
      const displayedWidth = img.clientWidth;
      const displayedHeight = img.clientHeight;
      
      console.log("Loading polygon coords:", coords);
      console.log("Image dimensions:", displayedWidth, displayedHeight);
      
      // Clear any existing points first
      clearPolygon();
      
      coords.forEach(coord => {
        const x = (coord[0] / videoWidth) * displayedWidth;
        const y = (coord[1] / videoHeight) * displayedHeight;
        console.log("Creating point at:", x, y, "from coord:", coord);
        createPoint(x, y);
      });
      
      updatePolygonLine();
      
      // If loading an existing polygon, mark it as complete
      if (coords.length >= 3) {
        completePolygon();
      }
    }

    function initPolygonOverlay() {
        const overlay = document.getElementById("polygonOverlay");
        overlay.innerHTML = '';
        zoneEditorState.polygonSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        zoneEditorState.polygonSvg.style.width = '100%';
        zoneEditorState.polygonSvg.style.height = '100%';
        zoneEditorState.polygonSvg.style.position = 'absolute';
        zoneEditorState.polygonSvg.style.top = '0';
        zoneEditorState.polygonSvg.style.left = '0';
        zoneEditorState.polygonSvg.style.pointerEvents = 'none';
        
        zoneEditorState.polygonPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        zoneEditorState.polygonPath.setAttribute('fill', 'none');
        zoneEditorState.polygonPath.setAttribute('stroke', '#ff0000');
        zoneEditorState.polygonPath.setAttribute('stroke-width', '2');
        zoneEditorState.polygonPath.setAttribute('stroke-linejoin', 'round');
        
        zoneEditorState.polygonSvg.appendChild(zoneEditorState.polygonPath);
        overlay.appendChild(zoneEditorState.polygonSvg);
    }

    function clearPolygon() {
        const overlay = document.getElementById("polygonOverlay");
        const points = overlay.querySelectorAll('.polygon-point');
        points.forEach(point => point.remove());
        zoneEditorState.firstPoint = null;
        zoneEditorState.isPolygonComplete = false;
        if (zoneEditorState.polygonPath) {
            zoneEditorState.polygonPath.setAttribute('d', '');
            zoneEditorState.polygonPath.setAttribute('fill', 'none');
            zoneEditorState.polygonPath.setAttribute('stroke', '#ff0000');
        }
        const previewEl = document.getElementById("zonePreview");
        previewEl.addEventListener('click', handlePreviewClick);
    }

    function handlePreviewClick(e) {
        const previewEl = document.getElementById("zonePreview");
        const rect = previewEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        if (zoneEditorState.firstPoint && isClickOnPoint(zoneEditorState.firstPoint, x, y)) {
            completePolygon();
            return;
        }
        createPoint(x, y);
        updatePolygonLine();
    }

    function completePolygon() {
        console.log("Completing polygon");
        if (zoneEditorState.polygonPath) {
            zoneEditorState.polygonPath.setAttribute('fill', 'rgba(0, 255, 0, 0.3)');
            zoneEditorState.polygonPath.setAttribute('stroke', '#00ff00');
        }
        const previewEl = document.getElementById("zonePreview");
        previewEl.removeEventListener('click', handlePreviewClick);
        zoneEditorState.isPolygonComplete = true;
        updatePolygonLine();
    }

    function createPoint(x, y) {
        const overlay = document.getElementById("polygonOverlay");
        const point = document.createElement('div');
        point.className = 'polygon-point';
        point.style.position = 'absolute';
        point.style.left = (x - 6) + 'px';
        point.style.top = (y - 6) + 'px';
        point.style.width = '12px';
        point.style.height = '12px';
        point.style.backgroundColor = '#ff0000';
        point.style.borderRadius = '50%';
        point.style.cursor = 'crosshair';
        point.style.zIndex = '20';
        point.style.border = '2px solid #ffffff';
        point.style.boxShadow = '0 0 3px rgba(0,0,0,0.5)';
        point.style.pointerEvents = 'auto';
        
        // Store first point reference
        if (!zoneEditorState.firstPoint) {
            zoneEditorState.firstPoint = point;
            // Make first point visually distinct
            point.style.backgroundColor = '#0000ff';
            point.style.border = '2px solid #ffffff';
            point.style.cursor = 'pointer'; // Make first point more clickable
        }
        
        // Add click listener to first point for completion
        if (zoneEditorState.firstPoint === point) {
            point.addEventListener('click', function(e) {
                e.stopPropagation();
                if (!zoneEditorState.isPolygonComplete) {
                    completePolygon();
                }
            });
        }
        
        overlay.appendChild(point);
        return point;
    }

    function updatePolygonLine() {
        const previewEl = document.getElementById("zonePreview");
        const points = Array.from(document.querySelectorAll('.polygon-point'));
        
        if (points.length === 0) {
            if (zoneEditorState.polygonPath) {
                zoneEditorState.polygonPath.setAttribute('d', '');
            }
            zoneEditorState.firstPoint = null;
            zoneEditorState.isPolygonComplete = false;
            return;
        }
        
        // Create SVG path for the polygon - just draw lines between points, don't close automatically
        const pathData = points.map((point, index) => {
            const rect = point.getBoundingClientRect();
            const previewRect = previewEl.getBoundingClientRect();
            const x = rect.left - previewRect.left + 6; // Center of point
            const y = rect.top - previewRect.top + 6;
            return `${index === 0 ? 'M' : 'L'} ${x} ${y}`;
        }).join(' ');
        
        // Only close the path if polygon is complete
        if (zoneEditorState.isPolygonComplete) {
            if (zoneEditorState.polygonPath) {
                zoneEditorState.polygonPath.setAttribute('d', pathData + ' Z');
            }
        } else {
            if (zoneEditorState.polygonPath) {
                zoneEditorState.polygonPath.setAttribute('d', pathData);
            }
        }
    }

    function startCameraStream(camName) {
      const videoId = `video-${camName}`;
      const placeholderId = `placeholder-${camName}`;
      const video = document.getElementById(videoId);
      const placeholder = document.getElementById(placeholderId);
      
      if (!video) {
        console.warn(`Video element not found for ${camName}`);
        return;
      }
      
      // Setup user interaction tracking for this video
      setupUserInteractionTracking(video);
      
      const encoded = encodeURIComponent(camName);
      const baseUrl = window.location.origin;
      const streamUrl = `${baseUrl}/${encoded}_raw/streams/${currentStreamDate}/stream.m3u8`;
      
      activeVideoStreams.set(camName, {
        video: video,
        hls: null,
        streamUrl: streamUrl,
        isPlaying: false
      });
      
      waitForManifest(streamUrl, 30, 1000).then(ready => {
        if (!ready) {
          if (placeholder) placeholder.textContent = 'Stream unavailable';
          return;
        }
        
        if (placeholder) placeholder.style.display = 'none';
        
        if (Hls.isSupported()) {
          const hls = new Hls({
            manifestLoadingTimeOut: 20000,
            manifestLoadingMaxRetry: Infinity,
            manifestLoadingRetryDelay: 2000,
          });

          hls.loadSource(streamUrl);
          hls.attachMedia(video);

          hls.on(Hls.Events.MANIFEST_PARSED, function () {
            video.play().catch(e => console.log('Auto-play prevented:', e));
            activeVideoStreams.get(camName).isPlaying = true;
          });

          hls.on(Hls.Events.ERROR, function (event, data) {
            if (data && data.fatal) {
              switch (data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  hls.startLoad(-1);
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  hls.recoverMediaError();
                  break;
                default:
                  cleanupCameraStream(camName);
                  if (placeholder) {
                    placeholder.textContent = 'Stream error';
                    placeholder.style.display = 'flex';
                  }
                  break;
              }
            }
          });

          activeVideoStreams.get(camName).hls = hls;
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
          video.src = streamUrl;
          video.addEventListener('loadedmetadata', function onMeta() {
            video.removeEventListener('loadedmetadata', onMeta);
            video.play().catch(e => console.log('Auto-play prevented:', e));
            activeVideoStreams.get(camName).isPlaying = true;
          });
        } else {
          if (placeholder) {
            placeholder.textContent = 'HLS not supported';
            placeholder.style.display = 'flex';
          }
        }
      }).catch(error => {
        console.error(`Error starting stream for ${camName}:`, error);
        if (placeholder) {
          placeholder.textContent = 'Stream error';
          placeholder.style.display = 'flex';
        }
      });
    }

    function cleanupCameraStream(camName) {
      const streamInfo = activeVideoStreams.get(camName);
      if (streamInfo) {
        if (streamInfo.hls && typeof streamInfo.hls.destroy === 'function') {
          streamInfo.hls.destroy();
        }
        if (streamInfo.video) {
          streamInfo.video.pause();
          streamInfo.video.removeAttribute('src');
          streamInfo.video.load();
        }
        activeVideoStreams.delete(camName);
      }
    }

    async function deleteCamera(cam) {
      if (!confirm(`Are you sure you want to delete ${cam}?`)) return;
      
      // Clean up the stream first
      cleanupCameraStream(cam);
      
      const res = await fetch(`/delete_camera?cam_name=${cam}`);
      if (res.ok) {
        fetchCameras();
      } else {
        alert("Failed to delete camera.");
      }
    }

    async function shutdownServer() {
      if (!confirm("Are you sure you want to shut down the server?")) return;
      
      // Clean up all streams
      activeVideoStreams.forEach((stream, camName) => {
        cleanupCameraStream(camName);
      });
      
      const res = await fetch('/shutdown');
      if (res.ok) {
        alert("Server is shutting down...");
      } else {
        alert("Shutdown failed.");
      }
    }

    async function fetchMaxStorage() {
      try {
        const res = await fetch('/get_max_storage');
        const data = await res.json();
        const input = document.getElementById('maxStorageInput');
        if (input && data.max_gb !== undefined) {
          input.value = data.max_gb;
        }
      } catch (e) {
        console.error("Failed to fetch max storage:", e);
      }
    }

    async function setMaxStorage() {
      const input = document.getElementById('maxStorageInput');
      const newVal = parseFloat(input.value);
      if (!newVal || isNaN(newVal)) {
        alert("Please enter a valid number");
        return;
      }
      if (!confirm(`Set max storage to ${newVal} GB?`)) return;
      await fetch(`/set_max_storage?max=${newVal}`);
      fetchMaxStorage();
    }

    document.getElementById('setMaxStorageBtn').addEventListener('click', setMaxStorage);

    // Refresh storage field every 10 seconds
    fetchMaxStorage();
    setInterval(fetchMaxStorage, 10000);

    document.getElementById("addCameraForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const form = e.target;
      const params = new URLSearchParams(new FormData(form)).toString();
      await fetch(`/add_camera?${params}`);
      form.reset();
      fetchCameras();
    });

    async function waitForManifest(url, maxRetries = 30, delay = 2000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (res.ok) {
            const text = await res.text();
            if (text.includes("#EXTINF")) return true;
          }
        } catch (err) {
          // ignore / retry
        }
        await new Promise(r => setTimeout(r, delay));
      }
      return false;
    }

    function attachHlsToVideo(url, video, startTime = null) {
      if (Hls.isSupported()) {
        const hls = new Hls({
          manifestLoadingTimeOut: 20000,
          manifestLoadingMaxRetry: Infinity,
          manifestLoadingRetryDelay: 2000,
          enableWorker: true,
          lowLatencyMode: true,
          backBufferLength: 0,
          liveSyncDurationCount: 3,
          liveMaxLatencyDurationCount: 10
        });

        hls.loadSource(url);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, function () {
          if (startTime !== null) video.currentTime = startTime;
          video.play().catch(()=>{});
        });

        hls.on(Hls.Events.ERROR, function (event, data) {
          if (data && data.fatal) {
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                hls.startLoad(-1);
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                hls.recoverMediaError();
                break;
              default:
                hls.destroy();
                break;
            }
          }
        });

        video._hlsInstance = hls;
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = url;
        video.addEventListener('loadedmetadata', function onMeta() {
          video.removeEventListener('loadedmetadata', onMeta);
          if (startTime !== null) video.currentTime = startTime;
          video.play().catch(()=>{});
        });
      } else {
        console.error("No HLS support in this browser.");
      }
    }

    async function toggleMultiView() {
      const container = document.getElementById('multiView');
      if (container.classList.contains('active')) {
        closeMultiView();
        return;
      }

      if (!window.currentCameras || window.currentCameras.length === 0) {
        alert("No cameras available.");
        return;
      }

      container.classList.add('active');

      const cams = window.currentCameras.slice();
      const base = window.location.origin;

      const count = cams.length;
      const cols = Math.ceil(Math.sqrt(count));
      const rows = Math.ceil(count / cols);
      container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      container.style.gridTemplateRows = `repeat(${rows}, auto)`;
      container.innerHTML = '';

      cams.forEach(cam => {
        const encoded = encodeURIComponent(cam);
        const videoUrl = `${base}/${encoded}_raw/streams/${currentStreamDate}/stream.m3u8`;

        const wrapper = document.createElement('div');
        wrapper.className = 'video-wrapper';
        const vid = document.createElement('video');
        vid.autoplay = true;
        vid.muted = true;
        vid.playsInline = true;
        vid.dataset.streamUrl = videoUrl;
        wrapper.appendChild(vid);
        container.appendChild(wrapper);

        (async () => {
          const ready = await waitForManifest(videoUrl, 60, 1000);
          if (!ready) {
            console.error("Stream never became available for", cam);
            const notice = document.createElement('div');
            notice.style.position = 'absolute';
            notice.style.color = 'white';
            notice.textContent = 'Stream unavailable';
            wrapper.appendChild(notice);
            return;
          }

          try {
            attachHlsToVideo(videoUrl, vid, null);
          } catch (e) {
            console.error("Failed to attach HLS for", cam, e);
          }
        })();
      });

      if (container.requestFullscreen) container.requestFullscreen();
    }

    function closeMultiView() {
      const container = document.getElementById('multiView');
      container.querySelectorAll('video').forEach(vid => {
        try {
          if (vid._hlsInstance && typeof vid._hlsInstance.destroy === 'function') {
            vid._hlsInstance.destroy();
            delete vid._hlsInstance;
          }
          vid.pause();
          vid.removeAttribute('src');
          vid.load();
        } catch (e) {
          console.warn('Error cleaning video', e);
        }
      });

      container.innerHTML = '';
      container.classList.remove('active');
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
    }
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        const mv = document.getElementById('multiView');
        if (mv.classList.contains('active')) closeMultiView();
      }
    });

    document.getElementById('multiView').addEventListener('click', e => {
      if (e.target.id === 'multiView') closeMultiView();
    });

    async function loadEventImages() {
      try {
        const res = await fetch(`/event_thumbs?folder=${currentStreamDate}`);
        const data = await res.json();
        const container = document.getElementById("eventImagesContainer");
        
        if (data.images && data.images.length > 0) {
          let html = '';
          data.images.forEach(img => {
            html += `
              <div class="event-image-item">
                <img src="${img.url}" alt="Event" onclick="viewImage('${img.url}')">
                <div class="event-image-info">
                  <strong>${img.cam_name || 'Camera'}</strong>
                </div>
                <div class="event-image-actions">
                  <button title="View" onclick="viewImage('${img.url}')">
                    <span class="icon">
                      <svg><use href="#icon-magnify"></use></svg>
                    </span>
                  </button>
                  <button title="Play" onclick="playVideoAtTime('${img.cam_name}', ${img.timestamp})">
                    <span class="icon">
                      <svg><use href="#icon-play"></use></svg>
                    </span>
                  </button>
                  <button title="Play All" onclick="playAllCamerasAtTime(${img.timestamp})">
                    <span class="icon">
                      <svg><use href="#icon-play-all"></use></svg>
                    </span>
                  </button>
                </div>
              </div>
            `;
          });
          container.innerHTML = html;
        } else {
          container.innerHTML = '<p style="text-align:center; color:#666; width:100%;">No events detected yet.</p>';
        }
      } catch (err) {
        console.error("Failed to load event images:", err);
        const container = document.getElementById("eventImagesContainer");
        container.innerHTML = '<p style="text-align:center; color:#red; width:100%;">Error loading events.</p>';
      }
    }

    function viewImage(imageSrc) {
      const previewModal = document.getElementById("imagePreviewModal");
      const previewImage = document.getElementById("previewImage");
      previewImage.src = imageSrc;
      previewModal.style.display = "flex";
    }

    function closeImagePreview() {
      document.getElementById("imagePreviewModal").style.display = "none";
    }

    function playVideoAtTime(camName, timestamp) {
      // Find the video element for this camera
      const videoId = `video-${camName}`;
      const video = document.getElementById(videoId);
      
      if (video) {
        // Calculate the time position in the video (assuming timestamp is in seconds)
        video.currentTime = timestamp;
        video.play().catch(e => console.log('Auto-play prevented:', e));
        
        // Scroll to the camera card
        const cameraCard = video.closest('.camera-card');
        if (cameraCard) {
          cameraCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Add a highlight effect
          cameraCard.style.boxShadow = '0 0 0 3px #007bff';
          setTimeout(() => {
            cameraCard.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
          }, 2000);
        }
      } else {
        alert(`Camera ${camName} not found in current view`);
      }
    }

    function playAllCamerasAtTime(timestamp) {
      console.log(`Playing all cameras at timestamp: ${timestamp}`);
      
      // Play all available cameras at the same timestamp
      if (window.currentCameras && window.currentCameras.length > 0) {
        window.currentCameras.forEach(camName => {
          const videoId = `video-${camName}`;
          const video = document.getElementById(videoId);
          
          if (video) {
            video.currentTime = timestamp;
            video.play().catch(e => console.log(`Auto-play prevented for ${camName}:`, e));
          }
        });
        
        // Scroll to the first camera card
        const firstCameraCard = document.querySelector('.camera-card');
        if (firstCameraCard) {
          firstCameraCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Highlight all camera cards briefly
        document.querySelectorAll('.camera-card').forEach(card => {
          card.style.boxShadow = '0 0 0 3px #6f42c1';
          setTimeout(() => {
            card.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
          }, 2000);
        });
      } else {
        alert("No cameras available to play");
      }
    }

    // Close modal when clicking outside the image
    window.addEventListener("click", function(event) {
      const modal = document.getElementById("imagePreviewModal");
      if (event.target === modal) {
        closeImagePreview();
      }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape') {
        closeImagePreview();
      }
    });

    fetchCameras();
    setInterval(fetchCameras, 5000);
  </script>
</body>
</html>