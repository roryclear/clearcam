<!DOCTYPE html>
<html>
<head>
  <style>
    .camera-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .camera-card {
      width: 380px; /* Increased from 320px */
      border: 1px solid #ccc;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
      font-family: sans-serif;
    }
    .camera-card .video-container {
      width: 100%;
      height: 240px; /* Increased from 180px */
      background: #000;
      position: relative;
    }
    .camera-card video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    .camera-card .video-placeholder {
      width: 100%;
      height: 100%;
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
      position: absolute;
      top: 0;
      left: 0;
    }
    .camera-card .camera-info {
      padding: 12px;
      background: #f9f9f9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .camera-card .camera-name {
      font-weight: bold;
      cursor: pointer;
      color: #007bff;
      text-decoration: none;
      font-size: 16px;
    }
    .camera-card .camera-name:hover {
      text-decoration: underline;
    }
    .camera-card button {
      padding: 6px 12px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .camera-card button:hover {
      background: #c82333;
    }
    .form-section {
      margin-top: 20px;
      font-family: sans-serif;
    }
    .form-section input {
      padding: 6px;
      margin: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 200px;
    }
    .form-section button {
      padding: 6px 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .form-section button:hover {
      background: #0056b3;
    }
    .shutdown-wrapper {
      margin-top: 20px;
    }

    /* Multi-view overlay grid */
    #multiView {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: black;
      z-index: 9999;
      padding: 10px;
      box-sizing: border-box;
      justify-content: center;
      align-items: center;
      grid-gap: 10px;
    }
    #multiView.active {
      display: grid;
      justify-items: center;
      align-items: center;
    }
    #multiView .video-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #multiView video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
    }
    .multi-view-wrapper {
      margin-top: 10px;
      text-align: left;
    }
    .multi-view-wrapper button {
      padding: 6px 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .multi-view-wrapper button:hover {
      background: #0056b3;
    }
  </style>
</head>
<body>
  <div id="cameraList" class="camera-grid"></div>
  <div class="multi-view-wrapper">
    <button onclick="toggleMultiView()">Multi View</button>
  </div>

  <div class="form-section">
    <form id="addCameraForm">
      <input type="text" name="cam_name" placeholder="Camera Name" required>
      <input type="text" name="rtsp" placeholder="RTSP Link" required>
      <button type="submit">Add Camera</button>
    </form>
    <div class="max-storage-control" style="display: flex; flex-direction: column; align-items: flex-start; margin-top: 10px;">
      <label for="maxStorageInput" style="margin-bottom: 4px;">Set Max Storage (GB):</label>
      <div style="display: flex; align-items: center; gap: 6px;">
        <input type="number" id="maxStorageInput" min="1" style="width: 120px;">
        <button type="button" id="setMaxStorageBtn">Set</button>
      </div>
    </div>
    <div class="shutdown-wrapper">
      <button class="shutdown-button" onclick="shutdownServer()">Shutdown Server</button>
    </div>
  </div>

  <div id="multiView"></div>

  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script>
    // Track active video streams
    const activeVideoStreams = new Map();

    // Track visibility state
    let wasHidden = false;

    // Listen for page visibility changes
    document.addEventListener('visibilitychange', function() {
      if (!document.hidden && wasHidden) {
        // Page became visible again after being hidden
        console.log('Tab became active, seeking all streams to live');
        seekAllStreamsToLive();
      }
      wasHidden = document.hidden;
    });

    function seekAllStreamsToLive() {
      activeVideoStreams.forEach((streamInfo, camName) => {
        if (streamInfo.video && streamInfo.video.readyState >= 2) { // HAVE_CURRENT_DATA or better
          seekToLive(streamInfo.video);
        }
      });
    }

    function seekToLive(video) {
      if (video.seekable && video.seekable.length > 0) {
        try {
          const end = video.seekable.end(video.seekable.length - 1);
          const currentTime = video.currentTime;
          const liveThreshold = 10; // seconds from live edge
          
          // Only seek if we're more than threshold seconds behind live
          if (end - currentTime > liveThreshold) {
            video.currentTime = Math.max(0, end - 2); // 2 seconds from live edge
            console.log('Seeking to live edge:', video.currentTime, 'from', currentTime);
          }
        } catch (e) {
          console.warn('Error seeking to live:', e);
        }
      }
    }

    // Periodic live seek for HLS streams (in case they fall behind)
    setInterval(() => {
      if (!document.hidden) {
        activeVideoStreams.forEach((streamInfo, camName) => {
          if (streamInfo.video && streamInfo.video.readyState >= 2) {
            seekToLive(streamInfo.video);
          }
        });
      }
    }, 30000); // Check every 30 seconds

    async function fetchCameras() {
      const res = await fetch('/list_cameras');
      const cams = await res.json();
      const container = document.getElementById("cameraList");
      
      // Store current camera list
      const previousCameras = window.currentCameras || [];
      window.currentCameras = cams;
      
      // Get existing camera cards to preserve video elements
      const existingCards = new Map();
      container.querySelectorAll('.camera-card').forEach(card => {
        const camName = card.dataset.camera;
        if (camName) {
          existingCards.set(camName, card);
        }
      });
      
      // Update the container with minimal DOM changes
      const newCards = [];
      
      cams.forEach(cam => {
        let card = existingCards.get(cam);
        
        if (card) {
          // Card already exists, just update if needed
          const nameSpan = card.querySelector('.camera-name');
          if (nameSpan && nameSpan.textContent !== cam) {
            nameSpan.textContent = cam;
          }
          newCards.push(card);
        } else {
          // Create new card
          card = createCameraCard(cam);
          newCards.push(card);
        }
      });
      
      // Only update DOM if there are changes
      const currentCards = Array.from(container.children);
      const needsUpdate = newCards.length !== currentCards.length || 
                         !newCards.every((card, index) => currentCards[index] === card);
      
      if (needsUpdate) {
        container.innerHTML = '';
        newCards.forEach(card => container.appendChild(card));
      }
      
      // Start streams for new cameras
      cams.forEach(cam => {
        if (!activeVideoStreams.has(cam)) {
          startCameraStream(cam);
        }
      });
      
      // Clean up streams for removed cameras
      previousCameras.forEach(cameraName => {
        if (!cams.includes(cameraName)) {
          cleanupCameraStream(cameraName);
        }
      });
    }

    function createCameraCard(camName) {
      const card = document.createElement('div');
      card.className = 'camera-card';
      card.dataset.camera = camName;
      
      const videoId = `video-${camName}`;
      const placeholderId = `placeholder-${camName}`;
      
      card.innerHTML = `
        <div class="video-container">
          <video id="${videoId}" controls muted playsinline></video>
          <div class="video-placeholder" id="${placeholderId}">Loading stream...</div>
        </div>
        <div class="camera-info">
          <a href="/?cam=${encodeURIComponent(camName)}" class="camera-name" target="_blank">${camName}</a>
          <button onclick="deleteCamera('${camName}')">Delete</button>
        </div>
      `;
      
      return card;
    }

    function startCameraStream(camName) {
      const videoId = `video-${camName}`;
      const placeholderId = `placeholder-${camName}`;
      const video = document.getElementById(videoId);
      const placeholder = document.getElementById(placeholderId);
      
      if (!video) {
        console.warn(`Video element not found for ${camName}`);
        return;
      }
      
      const encoded = encodeURIComponent(camName);
      const today = new Date().toLocaleDateString('en-CA');
      const streamUrl = `http://localhost:8080/${encoded}_raw/streams/${today}/stream.m3u8`;
      
      // Mark as active
      activeVideoStreams.set(camName, {
        video: video,
        hls: null,
        streamUrl: streamUrl,
        isPlaying: false
      });
      
      // Wait for manifest and start playback
      waitForManifest(streamUrl, 30, 1000).then(ready => {
        if (!ready) {
          if (placeholder) placeholder.textContent = 'Stream unavailable';
          return;
        }
        
        if (placeholder) placeholder.style.display = 'none';
        
        if (Hls.isSupported()) {
          const hls = new Hls({
            manifestLoadingTimeOut: 20000,
            manifestLoadingMaxRetry: Infinity,
            manifestLoadingRetryDelay: 2000,
            enableWorker: true,
            lowLatencyMode: true,
            backBufferLength: 0,
            liveSyncDurationCount: 1, // Stay closer to live
            liveMaxLatencyDurationCount: 5 // Allow some latency but not too much
          });

          hls.loadSource(streamUrl);
          hls.attachMedia(video);

          hls.on(Hls.Events.MANIFEST_PARSED, function () {
            video.play().catch(e => console.log('Auto-play prevented:', e));
            activeVideoStreams.get(camName).isPlaying = true;
            
            // Initial seek to live
            setTimeout(() => seekToLive(video), 1000);
          });

          hls.on(Hls.Events.ERROR, function (event, data) {
            if (data && data.fatal) {
              switch (data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  hls.startLoad(-1);
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  hls.recoverMediaError();
                  break;
                default:
                  cleanupCameraStream(camName);
                  if (placeholder) {
                    placeholder.textContent = 'Stream error';
                    placeholder.style.display = 'flex';
                  }
                  break;
              }
            }
          });

          // Store reference for cleanup
          activeVideoStreams.get(camName).hls = hls;
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
          video.src = streamUrl;
          video.addEventListener('loadedmetadata', function onMeta() {
            video.removeEventListener('loadedmetadata', onMeta);
            video.play().catch(e => console.log('Auto-play prevented:', e));
            activeVideoStreams.get(camName).isPlaying = true;
            
            // Initial seek to live for native HLS
            setTimeout(() => seekToLive(video), 1000);
          });
        } else {
          if (placeholder) {
            placeholder.textContent = 'HLS not supported';
            placeholder.style.display = 'flex';
          }
        }
      }).catch(error => {
        console.error(`Error starting stream for ${camName}:`, error);
        if (placeholder) {
          placeholder.textContent = 'Stream error';
          placeholder.style.display = 'flex';
        }
      });
    }

    function cleanupCameraStream(camName) {
      const streamInfo = activeVideoStreams.get(camName);
      if (streamInfo) {
        if (streamInfo.hls && typeof streamInfo.hls.destroy === 'function') {
          streamInfo.hls.destroy();
        }
        if (streamInfo.video) {
          streamInfo.video.pause();
          streamInfo.video.removeAttribute('src');
          streamInfo.video.load();
        }
        activeVideoStreams.delete(camName);
      }
    }

    async function deleteCamera(cam) {
      if (!confirm(`Are you sure you want to delete ${cam}?`)) return;
      
      // Clean up the stream first
      cleanupCameraStream(cam);
      
      const res = await fetch(`/delete_camera?cam_name=${cam}`);
      if (res.ok) {
        fetchCameras();
      } else {
        alert("Failed to delete camera.");
      }
    }

    async function shutdownServer() {
      if (!confirm("Are you sure you want to shut down the server?")) return;
      
      // Clean up all streams
      activeVideoStreams.forEach((stream, camName) => {
        cleanupCameraStream(camName);
      });
      
      const res = await fetch('/shutdown');
      if (res.ok) {
        alert("Server is shutting down...");
      } else {
        alert("Shutdown failed.");
      }
    }

    async function fetchMaxStorage() {
      try {
        const res = await fetch('/get_max_storage');
        const data = await res.json();
        const input = document.getElementById('maxStorageInput');
        if (input && data.max_gb !== undefined) {
          input.value = data.max_gb;
        }
      } catch (e) {
        console.error("Failed to fetch max storage:", e);
      }
    }

    async function setMaxStorage() {
      const input = document.getElementById('maxStorageInput');
      const newVal = parseFloat(input.value);
      if (!newVal || isNaN(newVal)) {
        alert("Please enter a valid number");
        return;
      }
      if (!confirm(`Set max storage to ${newVal} GB?`)) return;
      await fetch(`/set_max_storage?max=${newVal}`);
      fetchMaxStorage();
    }

    document.getElementById('setMaxStorageBtn').addEventListener('click', setMaxStorage);

    // Refresh storage field every 10 seconds
    fetchMaxStorage();
    setInterval(fetchMaxStorage, 10000);

    document.getElementById("addCameraForm").addEventListener("submit", async (e) => {
      e.preventDefault();
      const form = e.target;
      const params = new URLSearchParams(new FormData(form)).toString();
      await fetch(`/add_camera?${params}`);
      form.reset();
      fetchCameras(); // Immediately refresh
    });

    async function waitForManifest(url, maxRetries = 30, delay = 2000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const res = await fetch(url, { cache: "no-store" });
          if (res.ok) {
            const text = await res.text();
            if (text.includes("#EXTINF")) return true;
          }
        } catch (err) {
          // ignore / retry
        }
        await new Promise(r => setTimeout(r, delay));
      }
      return false;
    }

    function attachHlsToVideo(url, video, startTime = null) {
      if (Hls.isSupported()) {
        const hls = new Hls({
          manifestLoadingTimeOut: 20000,
          manifestLoadingMaxRetry: Infinity,
          manifestLoadingRetryDelay: 2000,
          enableWorker: true,
          lowLatencyMode: true,
          backBufferLength: 0,
          liveSyncDurationCount: 1,
          liveMaxLatencyDurationCount: 5
        });

        hls.loadSource(url);
        hls.attachMedia(video);

        hls.on(Hls.Events.MANIFEST_PARSED, function () {
          if (startTime !== null) video.currentTime = startTime;
          video.play().catch(()=>{});
          
          // Seek to live for multi-view as well
          setTimeout(() => seekToLive(video), 1000);
        });

        hls.on(Hls.Events.ERROR, function (event, data) {
          if (data && data.fatal) {
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                hls.startLoad(-1);
                break;
              case Hls.ErrorTypes.MEDIA_ERROR:
                hls.recoverMediaError();
                break;
              default:
                hls.destroy();
                break;
            }
          }
        });

        // keep a reference so it can be cleaned up if we close multi-view
        video._hlsInstance = hls;
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        video.src = url;
        video.addEventListener('loadedmetadata', function onMeta() {
          video.removeEventListener('loadedmetadata', onMeta);
          if (startTime !== null) video.currentTime = startTime;
          video.play().catch(()=>{});
          
          // Seek to live for native HLS in multi-view
          setTimeout(() => seekToLive(video), 1000);
        });
      } else {
        console.error("No HLS support in this browser.");
      }
    }

    async function toggleMultiView() {
      const container = document.getElementById('multiView');
      if (container.classList.contains('active')) {
        closeMultiView();
        return;
      }

      if (!window.currentCameras || window.currentCameras.length === 0) {
        alert("No cameras available.");
        return;
      }

      container.classList.add('active');

      const cams = window.currentCameras.slice();
      const today = new Date().toLocaleDateString('en-CA');
      const base = "http://localhost:8080";

      const count = cams.length;
      const cols = Math.ceil(Math.sqrt(count));
      const rows = Math.ceil(count / cols);
      container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      container.style.gridTemplateRows = `repeat(${rows}, auto)`;
      container.innerHTML = '';

      // Create video placeholders & start loading each stream independently
      cams.forEach(cam => {
        const encoded = encodeURIComponent(cam);
        const videoUrl = `${base}/${encoded}_raw/streams/${today}/stream.m3u8`;

        const wrapper = document.createElement('div');
        wrapper.className = 'video-wrapper';
        const vid = document.createElement('video');
        vid.autoplay = true;
        vid.muted = true;
        vid.playsInline = true;
        vid.dataset.streamUrl = videoUrl;
        wrapper.appendChild(vid);
        container.appendChild(wrapper);

        (async () => {
          const ready = await waitForManifest(videoUrl, 60, 1000);
          if (!ready) {
            console.error("Stream never became available for", cam);
            const notice = document.createElement('div');
            notice.style.position = 'absolute';
            notice.style.color = 'white';
            notice.textContent = 'Stream unavailable';
            wrapper.appendChild(notice);
            return;
          }

          try {
            attachHlsToVideo(videoUrl, vid, null);
          } catch (e) {
            console.error("Failed to attach HLS for", cam, e);
          }

          let attempts = 0;
          const seekInterval = setInterval(() => {
            attempts++;
            if (vid.seekable && vid.seekable.length > 0) {
              try {
                const end = vid.seekable.end(0);
                vid.currentTime = Math.max(0, end - 0.5);
                clearInterval(seekInterval);
              } catch (e) {
                // ignoring seeking errors
              }
            }
            if (attempts > 10) clearInterval(seekInterval);
          }, 500);
        })();
      });

      if (container.requestFullscreen) container.requestFullscreen();
    }

    function closeMultiView() {
      const container = document.getElementById('multiView');
      container.querySelectorAll('video').forEach(vid => {
        try {
          if (vid._hlsInstance && typeof vid._hlsInstance.destroy === 'function') {
            vid._hlsInstance.destroy();
            delete vid._hlsInstance;
          }
          vid.pause();
          vid.removeAttribute('src');
          vid.load();
        } catch (e) {
          console.warn('Error cleaning video', e);
        }
      });

      container.innerHTML = '';
      container.classList.remove('active');
      if (document.fullscreenElement) document.exitFullscreen().catch(()=>{});
    }

    // Close multi-view on ESC or background click
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        const mv = document.getElementById('multiView');
        if (mv.classList.contains('active')) closeMultiView();
      }
    });

    document.getElementById('multiView').addEventListener('click', e => {
      if (e.target.id === 'multiView') closeMultiView();
    });

    // Refresh list every 5 seconds
    fetchCameras();
    setInterval(fetchCameras, 5000);
  </script>
</body>
</html>