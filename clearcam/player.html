<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 640px;
            background: black;
            aspect-ratio: 4 / 3;
        }
        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            width: 100%;
            max-width: 640px;
        }
        .top-controls {
            display: flex;
            align-items: center;
            width: 100%;
            justify-content: space-between;
        }
        #progress {
            width: 100%;
            height: 10px;
            background-color: #ccc;
            margin: 10px 0;
            cursor: pointer;
            position: relative;
            border-radius: 5px;
        }
        #progress-bar {
            width: 0;
            height: 100%;
            background-color: #007bff;
            border-radius: 5px;
        }
        button {
            padding: 5px 10px;
            margin: 0 5px;
        }
        #timeDisplay {
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div id="videoContainer">
        <video id="videoPlayer1" playsinline webkit-playsinline muted></video>
        <video id="videoPlayer2" playsinline webkit-playsinline muted style="display: none;"></video>
    </div>
    <div id="controls">
        <div class="top-controls">
            <button id="playPauseBtn">Play</button>
            <div id="timeDisplay">0:00 / 0:00</div>
        </div>
        <div id="progress">
            <div id="progress-bar"></div>
        </div>
    </div>
    <script>
    let segments = [];
    let totalDuration = 0;
    let retryTimeout = 2000;

    const videoPlayer1 = document.getElementById('videoPlayer1');
    const videoPlayer2 = document.getElementById('videoPlayer2');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const progressBar = document.getElementById('progress-bar');
    const progress = document.getElementById('progress');
    const timeDisplay = document.getElementById('timeDisplay');

    let currentVideo = videoPlayer1;
    let nextVideo = videoPlayer2;
    let currentSegment = 0;
    let isPlaying = false;
    let isScrubbing = false;
    let isWaitingForNextSegment = false;

    async function fetchSegments() {
        try {
            const startParam = segments.length;
            const response = await fetch(`/get-segments?start=${startParam}`);
            if (response.ok) {
                const newSegments = await response.json();
                if (Array.isArray(newSegments)) {
                    const oldTotalDuration = totalDuration;

                    let cumulativeStart = totalDuration;
                    newSegments.forEach((segment) => {
                        const timeDifference = segment.timeDifference || segment.duration;
                        const lostFrames = timeDifference - segment.duration;

                        const currentCumulativeStart = cumulativeStart;
                        cumulativeStart += timeDifference;

                        segments.push({
                            ...segment,
                            cumulativeStart: currentCumulativeStart,
                            lostFrames: lostFrames > 0 ? lostFrames : 0,
                        });
                    });

                    totalDuration = segments.reduce((sum, seg) => sum + (seg.timeDifference || seg.duration), 0);

                    if (totalDuration !== oldTotalDuration) {
                        updateTimeline();
                        preloadNextSegments();
                        if (!isPlaying && segments.length > 0 && !isWaitingForNextSegment) {
                            playSegment();
                        }
                        if (isWaitingForNextSegment && segments.length > currentSegment + 1) {
                            isWaitingForNextSegment = false;
                            switchToNextSegment();
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Failed to fetch segments:', error);
        }
    }

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
        return `${minutes}:${secs}`;
    }

    function updateTimeline() {
        const currentTime = currentVideo.currentTime + segments[currentSegment].cumulativeStart;
        progressBar.style.width = `${(currentTime / totalDuration) * 100}%`;
        timeDisplay.innerText = `${formatTime(currentTime)} / ${formatTime(totalDuration)}`;
    }

    function scrub(e) {
        const scrubTime = Math.min(((e.offsetX || e.touches[0].clientX - progress.getBoundingClientRect().left) / progress.offsetWidth) * totalDuration, totalDuration - 1);

        let targetSegment = segments.findIndex(segment => scrubTime < segment.cumulativeStart + segment.duration);
        targetSegment = targetSegment === -1 ? segments.length - 1 : targetSegment;

        const targetTime = scrubTime - segments[targetSegment].cumulativeStart;

        if (targetSegment >= 0 && targetSegment < segments.length) {
            currentSegment = targetSegment;
            currentVideo.src = segments[currentSegment].url;
            currentVideo.currentTime = targetTime;
            currentVideo.play();
            preloadNextSegments();
        }

        updateTimeline();
    }

    function startScrubbing(e) {
        isScrubbing = true;
        scrub(e);
        document.addEventListener("mousemove", scrubWhileDragging);
        document.addEventListener("mouseup", stopScrubbing);
        document.addEventListener("touchmove", scrubWhileDragging);
        document.addEventListener("touchend", stopScrubbing);
    }

    function scrubWhileDragging(e) {
        if (isScrubbing) {
            scrub(e);
        }
    }

    function stopScrubbing() {
        isScrubbing = false;
        document.removeEventListener("mousemove", scrubWhileDragging);
        document.removeEventListener("mouseup", stopScrubbing);
        document.removeEventListener("touchmove", scrubWhileDragging);
        document.removeEventListener("touchend", stopScrubbing);
    }

    function preloadNextSegments() {
        if (currentSegment + 1 < segments.length) {
            nextVideo.src = segments[currentSegment + 1].url;
            nextVideo.load();  // Force load for mobile
            nextVideo.preload = 'auto';
            nextVideo.play().then(() => {
                nextVideo.pause();
                nextVideo.currentTime = 0;  // Ensure it's ready to start instantly
            }).catch(err => console.warn("Preload error:", err));
        }
    }

    function playSegment() {
        if (segments.length > 0) {
            currentVideo.src = segments[currentSegment].url;
            currentVideo.currentTime = 0;
            currentVideo.style.display = "block";
            nextVideo.style.display = "none";

            currentVideo.play();
            isPlaying = true;
            playPauseBtn.innerText = "Pause";

            preloadNextSegments();
        }
    }

    function retrySegment(videoElement) {
        console.warn(`Retrying segment: ${segments[currentSegment].url}`);
        setTimeout(() => {
            videoElement.src = segments[currentSegment].url;
            videoElement.load();
            videoElement.play();
        }, retryTimeout);
    }

    function switchToNextSegment() {
        if (currentSegment + 1 < segments.length) {
            currentSegment++;
            let temp = currentVideo;
            currentVideo = nextVideo;
            nextVideo = temp;

            nextVideo.style.display = "none";
            currentVideo.style.display = "block";
            
            currentVideo.play().catch(() => {
                retrySegment(currentVideo);
            });

            setTimeout(() => preloadNextSegments(), 500); // Slightly earlier preloading for mobile
        } else {
            isWaitingForNextSegment = true;
        }
    }

    function handleTimeUpdate() {
        updateTimeline();
        if (!preloading && currentVideo.currentTime > currentVideo.duration - 5) {
            preloading = true;
            preloadNextSegments();
        }
    }

    currentVideo.addEventListener("timeupdate", handleTimeUpdate);
    nextVideo.addEventListener("timeupdate", handleTimeUpdate);

    progress.addEventListener("mousedown", startScrubbing);
    progress.addEventListener("touchstart", startScrubbing);

    setInterval(fetchSegments, 1000);

    currentVideo.addEventListener("ended", switchToNextSegment);
    nextVideo.addEventListener("ended", switchToNextSegment);

    currentVideo.addEventListener("error", () => retrySegment(currentVideo));
    nextVideo.addEventListener("error", () => retrySegment(nextVideo));

    playPauseBtn.addEventListener("click", () => {
        if (isPlaying) {
            currentVideo.pause();
            playPauseBtn.innerText = "Play";
            isPlaying = false;
        } else {
            currentVideo.play();
            playPauseBtn.innerText = "Pause";
            isPlaying = true;
        }
    });

    fetchSegments();
    </script>
    
</body>
</html>
