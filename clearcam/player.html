<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 640px;
            background: black;
            aspect-ratio: 4 / 3;
        }
        #videoContainer:hover #controls {
            opacity: 1;
        }
        .video-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }
        video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        #controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            box-sizing: border-box;
        }
        #controls.show {
            opacity: 1;
        }
        .top-controls {
            display: flex;
            align-items: center;
            width: 100%;
            justify-content: space-between;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        #progress {
            width: 100%;
            height: 10px;
            background-color: #ccc;
            cursor: pointer;
            position: relative;
            border-radius: 5px;
            box-sizing: border-box;
        }
        #progress-bar {
            width: 0;
            height: 100%;
            background-color: #007bff;
            border-radius: 5px;
        }
        button {
            background: none;
            border: none;
            padding: 0;
            margin: 0;
        }
        #timeDisplay {
            color: white;
            margin-left: 10px;
        }
        #fullscreenBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            padding: 8px;
            cursor: pointer;
            background: transparent;
            border: none;
            outline: none;
        }
        
        #controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
            box-sizing: border-box;
        }

        #controls.show {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out;
        }

    </style>
</head>
<body>
    <div id="videoContainer">
        <div class="video-wrapper">
            <video id="videoPlayer1" playsinline webkit-playsinline muted></video>
            <video id="videoPlayer2" playsinline webkit-playsinline muted style="display: none;"></video>
            <div id="controls">
                <div class="top-controls">
                    <button id="playPauseBtn">
                        <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="24px" height="24px">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="24px" height="24px" style="display: none;">
                            <path d="M6 19h4V5H6zm8-14v14h4V5h-4z"/>
                        </svg>
                    </button>
                    <div style="display: flex; align-items: center;">
                        <div id="timeDisplay">0:00 / 0:00</div>
                        <button id="fullscreenBtn" style="margin-left: 10px;">
                            <svg id="fullscreenIcon" xmlns="http://www.w3.org/2000/svg"
                                viewBox="0 0 24 24" fill="white" width="24px" height="24px">
                                <path d="M3 3h6v2H5v4H3zm12 0h6v6h-2V5h-4zm6 12v6h-6v-2h4v-4zm-12 6H3v-6h2v4h4z"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div id="progress">
                    <div id="progress-bar"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        let segments = [];
        let totalDuration = 0;
        let retryTimeout = 2000;

        const videoPlayer1 = document.getElementById('videoPlayer1');
        const videoPlayer2 = document.getElementById('videoPlayer2');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const progressBar = document.getElementById('progress-bar');
        const progress = document.getElementById('progress');
        const timeDisplay = document.getElementById('timeDisplay');

        let currentVideo = videoPlayer1;
        let nextVideo = videoPlayer2;
        let currentSegment = 0;
        let isPlaying = false;
        let isScrubbing = false;
        let isWaitingForNextSegment = false;
        let wasPlayingBeforeScrub = false;

        let hideControlsTimeout;
        const controls = document.getElementById('controls');
        const videoContainer = document.getElementById('videoContainer');

        function showControls() {
            controls.classList.add('show');
            clearTimeout(hideControlsTimeout);
            hideControlsTimeout = setTimeout(() => {
                controls.classList.remove('show');
                controls.style.transform = 'translateY(0.0001px)'; // Tiny nudge to force repaint
            }, 4000);
        }

        function hideControls() {
            controls.classList.remove('show');
            controls.style.transform = 'translateY(0.0001px)'; // Safari-specific hack
        }

        function toggleControls() {
            if (controls.classList.contains('show')) {
                hideControls();
            } else {
                showControls();
            }
        }
        
        function retrySegment(videoElement) {
            console.warn(`Retrying segment: ${segments[currentSegment].url}`);
            setTimeout(() => {
                videoElement.src = segments[currentSegment].url;
                videoElement.load();
                videoElement.play();
            }, retryTimeout);
        }

        function updateTimeline() {
            const startTimestamp = segments[0].timeStamp;
            const currentTime = startTimestamp + currentVideo.currentTime + segments[currentSegment].cumulativeStart;
            progressBar.style.width = `${(currentTime - startTimestamp) / totalDuration * 100}%`;
            timeDisplay.innerText = `${formatTime(currentTime)} / ${formatTime(startTimestamp + totalDuration)}`;
        }

        videoContainer.addEventListener('mousemove', showControls);
        videoContainer.addEventListener('mouseleave', hideControls);
        videoContainer.addEventListener('touchend', toggleControls);
        videoContainer.addEventListener('click', toggleControls);

        function togglePlayPause() {
            if (isPlaying) {
                currentVideo.pause();
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
                isPlaying = false;
            } else {
                currentVideo.play();
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
                isPlaying = true;
            }
        }

        currentVideo.addEventListener('click', togglePlayPause);
        nextVideo.addEventListener('click', togglePlayPause);
        playPauseBtn.addEventListener('click', togglePlayPause);

        videoContainer.addEventListener('dblclick', (e) => {
            const containerWidth = videoContainer.clientWidth;
            const x = e.clientX;
            const currentTime = currentVideo.currentTime + segments[currentSegment].cumulativeStart;

            if (x > containerWidth / 2) {
                // Double-tap/click on the right side to skip forward 10s
                let newTime = Math.min(currentTime + 10, totalDuration);
                seekToTime(newTime);
            } else {
                // Double-tap/click on the left side to rewind 10s
                let newTime = Math.max(currentTime - 10, 0);
                seekToTime(newTime);
            }

            updateTimeline();
        });

        function seekToTime(time) {
            let targetSegment = segments.findIndex(segment => time < segment.cumulativeStart + segment.duration);
            targetSegment = targetSegment === -1 ? segments.length - 1 : targetSegment;
            currentSegment = targetSegment;

            currentVideo.src = segments[currentSegment].url;
            currentVideo.currentTime = time - segments[currentSegment].cumulativeStart;

            if (isPlaying) {
                currentVideo.play();
            }
        }

        document.addEventListener("visibilitychange", () => {
            if (isPlaying && !document.hidden && segments.length > 0) {
                currentSegment = segments.length - 1;
                currentVideo.src = segments[currentSegment].url;
                currentVideo.currentTime = segments[currentSegment].duration;
                currentVideo.play().catch(() => {});
            }
        });

        async function fetchSegments() {
            try {
                const startParam = segments.length;

                // Get the current date in YYYY-MM-DD format
                const currentDate = new Date().toISOString().split('T')[0];

                const response = await fetch(`/get-segments?date=${currentDate}&start=${startParam}`);
                if (response.ok) {
                    const newSegments = await response.json();
                    if (Array.isArray(newSegments)) {
                        const oldTotalDuration = totalDuration;

                        let cumulativeStart = totalDuration;
                        newSegments.forEach((segment) => {
                            const timeDifference = segment.timeDifference || segment.duration;
                            const lostFrames = timeDifference - segment.duration;

                            const currentCumulativeStart = cumulativeStart;
                            cumulativeStart += timeDifference;

                            segments.push({
                                ...segment,
                                cumulativeStart: currentCumulativeStart,
                                lostFrames: lostFrames > 0 ? lostFrames : 0,
                            });
                        });

                        totalDuration = segments.reduce((sum, seg) => sum + (seg.timeDifference || seg.duration), 0);

                        if (totalDuration !== oldTotalDuration) {
                            updateTimeline();
                            preloadNextSegments();
                            
                            // TODO: Improve autoplay logic
                            if (currentVideo.currentTime + segments[currentSegment].cumulativeStart == 0 ||
                                (isPlaying && isWaitingForNextSegment && segments.length < currentSegment + 1)) {
                                playSegment();
                            }
                            if (isWaitingForNextSegment && segments.length > currentSegment + 1) {
                                isWaitingForNextSegment = false;
                                switchToNextSegment();
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to fetch segments:', error);
            }
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600).toString().padStart(2, '0');
            const minutes = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${hours}:${minutes}:${secs}`;
        }

        function scrub(e) {
            const scrubTime = Math.min(((e.offsetX || e.touches[0].clientX - progress.getBoundingClientRect().left) / progress.offsetWidth) * totalDuration, totalDuration - 1);

            let targetSegment = segments.findIndex(segment => scrubTime < segment.cumulativeStart + segment.duration);
            targetSegment = targetSegment === -1 ? segments.length - 1 : targetSegment;

            const targetTime = scrubTime - segments[targetSegment].cumulativeStart;

            if (targetSegment >= 0 && targetSegment < segments.length) {
                currentSegment = targetSegment;
                currentVideo.src = segments[currentSegment].url;
                currentVideo.currentTime = targetTime;
                if (wasPlayingBeforeScrub) {
                    currentVideo.play();
                }
                preloadNextSegments();
            }

            updateTimeline();
        }

        function startScrubbing(e) {
            wasPlayingBeforeScrub = !currentVideo.paused;
            isScrubbing = true;
            scrub(e);
            document.addEventListener("mousemove", scrubWhileDragging);
            document.addEventListener("mouseup", stopScrubbing);
            document.addEventListener("touchmove", scrubWhileDragging);
            document.addEventListener("touchend", stopScrubbing);
        }

        function scrubWhileDragging(e) {
            if (isScrubbing) {
                scrub(e);
            }
        }

        function stopScrubbing() {
            isScrubbing = false;
            if (!wasPlayingBeforeScrub) {
                currentVideo.pause();
            }
            document.removeEventListener("mousemove", scrubWhileDragging);
            document.removeEventListener("mouseup", stopScrubbing);
            document.removeEventListener("touchmove", scrubWhileDragging);
            document.removeEventListener("touchend", stopScrubbing);
        }

        function preloadNextSegments() {
            if (currentSegment + 1 < segments.length) {
                nextVideo.src = segments[currentSegment + 1].url;
                nextVideo.load();  // Force load for mobile
                nextVideo.preload = 'auto';
                nextVideo.play().then(() => {
                    nextVideo.pause();
                    nextVideo.currentTime = 0;  // Ensure it's ready to start instantly
                }).catch(err => console.warn("Preload error:", err));
            }
        }

        function playSegment() {
            if (segments.length > 0) {
                currentVideo.src = segments[currentSegment].url;
                currentVideo.currentTime = 0;
                currentVideo.style.display = "block";
                nextVideo.style.display = "none";

                currentVideo.play();
                isPlaying = true;
                playIcon.style.display = "none";
                pauseIcon.style.display = "block";

                preloadNextSegments();
            }
        }

        function switchToNextSegment() {
            if (currentSegment + 1 < segments.length) {
                currentSegment++;
                let temp = currentVideo;
                currentVideo = nextVideo;
                nextVideo = temp;

                nextVideo.style.display = "none";
                currentVideo.style.display = "block";
                
                currentVideo.play().catch(() => {
                    retrySegment(currentVideo);
                });

                setTimeout(() => preloadNextSegments(), 500); // Slightly earlier preloading for mobile
            } else {
                isWaitingForNextSegment = true;
            }
        }

        function handleTimeUpdate() {
            updateTimeline();
            if (!preloading && currentVideo.currentTime > currentVideo.duration - 5) {
                preloading = true;
                preloadNextSegments();
            }
        }

        currentVideo.addEventListener("timeupdate", handleTimeUpdate);
        nextVideo.addEventListener("timeupdate", handleTimeUpdate);

        progress.addEventListener("mousedown", startScrubbing);
        progress.addEventListener("touchstart", startScrubbing);

        setInterval(fetchSegments, 1000);

        currentVideo.addEventListener("ended", switchToNextSegment);
        nextVideo.addEventListener("ended", switchToNextSegment);

        currentVideo.addEventListener("error", () => retrySegment(currentVideo));
        nextVideo.addEventListener("error", () => retrySegment(nextVideo));

        const fullscreenBtn = document.getElementById('fullscreenBtn');

                fullscreenBtn.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        if (videoContainer.requestFullscreen) {
                            videoContainer.requestFullscreen();
                        } else if (videoContainer.mozRequestFullScreen) { /* Firefox */
                            videoContainer.mozRequestFullScreen();
                        } else if (videoContainer.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                            videoContainer.webkitRequestFullscreen();
                        } else if (videoContainer.msRequestFullscreen) { /* IE/Edge */
                            videoContainer.msRequestFullscreen();
                        }
                    } else {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.mozCancelFullScreen) { /* Firefox */
                            document.mozCancelFullScreen();
                        } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                            document.webkitExitFullscreen();
                        } else if (document.msExitFullscreen) { /* IE/Edge */
                            document.msExitFullscreen();
                        }
                    }
                });
        
        function isMobile() {
            return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        }

        if (isMobile()) {
            document.getElementById('fullscreenBtn').style.display = 'none';
        }

        
        fetchSegments();
    </script>
</body>
</html>
